I propose a new way of classifying what meaningful errors actually are so that
they can be presented to the user in an appropriate and ac tionable way.  

Catastrophic errors (those errors that cannot be recovered from) must be
immediately and loudly presented to the user if and only if the component that
must terminate is *critical* to the functionality of the system.  Taking that
into consideration, Microsoft Windows' BSOD can actually be praised for being an
appropriate method for error display, however it comes nowhere near to being
*meaningful* to the end -user.  Mac OS X kernel panics, by contrast, present the
user with a clear and straightforward resolution to a serious problem: That the
computer must be reset.  It even presents the error in a number of common
languages to aid international users.  The reasoning behind suc h intrusive
errors is clear: the system cannot, or should not, recover from a given
component failure, and so the user should do the logi cal thing and restart
their system at the cost of lost work hours.  That said, there have always been
applications that violate these rul es.  Games like Chess.app and Words With
Friends, even company-sanctioned apps like the App Store and iTunes that are
renowned for closin g themselves when they cannot establish a stable internet
connection.  This is simply unacceptable.  When an application cannot function
because it requires a persistent connection to the internet, it should be
clearly explained as such.  It should become immediately obviou s to a user
presented with an empty store screen or game canvas that the application cannot
continue to function normally, and they shoul d be given the opportunity to quit
it themselves.  If a program must self-terminate make it clear to the user that
it is doing so.  Simpl y presenting a modal dialog or submitting a local
notification to the system queue is not enough for important processes. (I
should hardl y think anyone would want to see the OS X window server present
a growl notification of its impending death!)

Major errors (those requiring user action) such as an inability to reach
a particular content server or a failed plugin load should be pr esented modally
to the user if and only if the application cannot perform its main duties until
the error has been resolved.  The importa nt thing to remember about these kinds
of errors is that they can actually be fixed by the user's doing something.  If
an application can not load a plugin, prompt the user to refresh the page.  If
it cannot download a required file, prompt the user to find a more stable int
ernet connection.  If, however, a modal dialog is presented simply because
a parser failed, or a short-lived re-queueable operation faile d, then this
indicates a serious error in program design.  Such errors are unactionable, and
qualify as application-logic errors.

Logic errors (those specific to the program at hand or one of its dependencies)
should *never* be shown to the user unmodified.  There is absolutely no reason
a user should care about your shoddy craftsmanship, nor should they have to ever
get a glimpse into the unfortunate maw of your error-chaining mechanism.  Error
codes should be converted to *meaningful* and actionable descriptions and should
be present ed as discreetly as possible.  A good example of this is hitting API
limits.  A good program that hits an API limit should alert the user with
a non-intrusive banner that the application can no longer request content for
the day, apologize for the inconvenience, and present a helpful document or link
as to why the error has occurred if necessary.  It should *not* attempt to
present a modal dialog containing a raw error code, an error description
specific to a framework or library, or one that is unactionable.  A simple rule
of thumb is to kee p them to yourself and cover all your bases in regards to
error handling so one doesn't happen to slip through only to waste the user's
time.

Minor errors (all others) should *never* be presented to the user.  The same
rules about application logic errors apply double to this cl ass of errors.
The user should never have to deal with a recoverable exception, the failure
of a re-queueable operation, the inability t o reach a given branch in an
if-statement, and whatever trivial byte-vomit happened to get pushed into
production.  Nobody wants to see y our mistakes, least of all you.  Fix it.

